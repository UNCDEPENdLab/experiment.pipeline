################################
task: shrooms
################################
variable_mapping: #column names in $behav dataset for subject, mapped to standard constructs in experiment validation
  id: id
  run:
  run_trial:
  run_condition:
  block: block
  block_trial: block_trial
  block_condition:
  trial: trial
  trial_condition: condition
  event: event
################################
definitions: #shared key mapping for behavior across blocks
  behav: &behav
    response: key_pressed
    valid: [space, None]
    rt: rt
    start_time: #key_resp_10.started
    end_time: #key_resp_10.stopped
  eye: &eye
    expected_edf_fields: ["raw", "sacc", "fix", "blinks", "msg", "input", "button", "info", "asc_file", "edf_file"]
    meta_check:
      meta_vars: ["sample.rate", "model", "mono", "pupil.dtype", "screen.x", "screen.y", "version"]
      meta_vals: ["1000", "EyeLink 1000", "TRUE", "AREA", "1920", "1080", "4.594"]
      recording_time: [1680, 360] # [expected time (seconds), margin of error above and below]
    inherit_btw_tr: # do certain between-trial messages need to be extracted for any reason? If left out, will skip
      calibration_check:
        cal: ["!CAL CALIBRATION HV9"]
        val: ["!CAL VALIDATION HV9"]
      move_to_within:
        str: ["TRIALID", "END_RECORDING", "TRIAL "]
        align_msg: ["!MODE RECORD CR 1000 2 1 R", "TRIAL_OUTCOME", "TRIAL_OUTCOME"]
        pre_post: ["pre", "post", "post"]
        # align_pos: ["after_shift", "after_shift", "after_shift"] # right now simply do the same to all messages wrt the message of requested alignment. If one wanted to get very nit-picky they could move messages before or after and block/spread/shift them as described in coincident_messages.    pre_event:
    event_info:
      msg: ["TRIALID"]
      extraction_method: regex  #regex_single. can think about adding others later (e.g. multiple regex, or seperate .csv with info).
      msg_extract: ["(?<=\\s).+"] # everything following first white space. N.B. this must be double quoted! Otherwise when the config is read, backslashes will be escaped with addtional backslashes. e.g  ["(?<=\\s).+"] will get read into the R session as "(?<=\\\\s).+".
      split_by: ["_"]
      msg_parts: ["block", "block_trial", "eventn", "event"]
      msg_seq: # &msg_seq #decided to comment this out below for the sake of simplicity.
        msg_start: ["!MODE RECORD CR 1000 2 1 R", "TRIALID", "SYNCTIME", "DISPLAY ON"]
        msg_end: [ "TRIAL_OUTCOME ", "TRIAL "]
        eval_middle: TRUE #smoosh certain event-specific (taken from below) messages in between the task-general beginning and end messages.
        ordered: TRUE
        # start_order: [1,1,1,2] #super nit-picky option could allow for certain unimportatnt messages to be shuffled within a block. For now, just set ordered =TRUE and enforce that they must be exactly ordered.
    gaze:
      aoi:
        indicator: ["!V IAREA RECTANGLE"]
        extraction_method: regex
        extract_coords: ["\\d{3,4} \\d{3,4} \\d{3,4} \\d{3,4}"]
        extract_labs: ["[a-z]+$"]
        split_coords: " "
        tag_raw: FALSE #unless there is some strong reason to need super-high resolution on AOI position (moving AOIs, which are not currently supported), this should be FALSE. Default is FALSE if not included in config.
      downsample:
        factor: 50
        method: "mean"
      interpolate:
        data: "downsampled" # can be raw, downsampled, or both. Right now only downsampled is supported.
        algor: "stine"
        maxgap: 500 ### in MS, will use the original sampling frequency and downsampling factor to convert to nmeasurements.
    pupil:

    return_raw: TRUE # If false, and data are downsampled, will remove the raw data from the ep object.
    # coincident_msg: 11/1/20: deprecated, but can revive if there is interest. blocked #placeholder for now for messages that occur at the exact same timestamp in the .edf file. blocked will essentially expand the number of rows in the raw df by creating multiple rows with the same ET measurements but different messages. If it beceomes relevant later, can include options for "spread" which keeps the same number of rows and spreads messages at the same timestamp into multiple columns or "shift" which could just shift multiple messages "down" to the few milleseconds after the timestamp of coincident messages. Though as of 10/29/20 I don"t see any reason why we"d need to code around simple "blocked structure".
  phys:
    parport_task_begin: 151
################################
runs: #["run1", "run2", "run3"] #no runs for our behavioral tasks, but could be specified if needed
################################
blocks:
  approach-ins:
    # block_wrappers: #helps clarify difference between block-level onset and offset
    #   onset: #block-level onset
    #     parport_code:
    #     #eye_msg: [BLOCK_BEGIN]
    #   offset: #block-level offset
    #     parport_code:
    #     #eye_msg: [BLOCK_END]
    ntrials: [48, 72]
    behav: *behav
    events:  ## leave blank #["shroom", "feedback"]
      # event_key: stim   #keep with variable mapping conventions
      shroom:
        #parport_code: "xyz"
        eye:
          #<<: *msg_seq # as useful as this may be in the future, currently an unneccesary thing.
          mid_msg: ["!V IAREA RECTANGLE 1", "!V IAREA RECTANGLE 2", "!V IAREA RECTANGLE 3", "mouse on", "DISPLAY OFF"] #these will be event-specific messages that will fall between msg_start and msg_end
      feedback:
        #parport_code: "xyz"
        eye:
          mid_msg: ["!V IAREA RECTANGLE 1", "DISPLAY OFF",] # ${definitions.eye.aoi_indicator} would be nice to have something like this. but probably overly complicated
  approach-pav:
    # block_wrappers:
    #   onset: #block-level onset
    #     parport_code: 84
    #     #eye_msg: [BLOCK_BEGIN]
    #   offset: #block-level offset
    #     parport_code: 92
    #     #eye_msg: [BLOCK_END]
    ntrials: 60
    behav: *behav
    events:
      fractal:
        eye:
          mid_msg: ["!V IAREA RECTANGLE 1"]
      feedback:
        eye:
          mid_msg: ["!V IAREA RECTANGLE 1", "DISPLAY OFF"]
  approach-feedback:
    # block_wrappers:
    #   onset: #block-level onset
    #     parport_code: 84
    #     #eye_msg: [BLOCK_BEGIN]
    #   offset: #block-level offset
    #     parport_code: 92
    #     #eye_msg: [BLOCK_END]
    ntrials: 10
    behav: *behav
    events:
      fractals:
        eye:
          mid_msg: ["!V IAREA RECTANGLE 1", "!V IAREA RECTANGLE 2", "mouse on", "DISPLAY OFF"]


  approach-pit:
    # block_wrappers:
    #   onset: #block-level onset
    #     parport_code: 84
    #     #eye_msg: [BLOCK_BEGIN]
    #   offset: #block-level offset
    #     parport_code: 92
    #     #eye_msg: [BLOCK_END]
    ntrials: 90
    behav: *behav
    events:
      compound:
        eye:
          mid_msg: ["!V IAREA RECTANGLE 1", "mouse on", "DISPLAY OFF"]

