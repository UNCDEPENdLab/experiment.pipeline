# Import Data
#
# Imports data from various tasks utilizing a single schema
# to perform uniform unary operations and analysis.
#
# Some useful keyboard shortcuts for package authoring:
#
#   Install Package:           'Ctrl + Shift + B'
#   Check Package:             'Ctrl + Shift + E'
#   Test Package:              'Ctrl + Shift + T'

#' Finds Unprocessed files based on file names
#'
#' Finds files that exist in a raw directory, which do not have a counterpart
#' in a processed directory.  Files names are expected to have the same file name
#' i.e. foo_bar.fb <-> foo_bar.bf
#'
#' @param dir.raw Directory location for the raw directory.
#' @param dir.processed Directory location for the processed directory.
#' @param input.file.extension File extension to look for (empty string to disregard (standard))
#'
#' @return raw file names
find.unprocessed <- function(dir.raw, dir.processed, input.file.extension = '') {
  log.debug("Checking for unprocessed data.", "IMPORT")

  # Try for Read-File Exception
  tryCatch({
    raw <- list.files(dir.raw, pattern = paste(input.file.extension, "$", sep = ''))
    processed <- list.files(dir.processed)
  }, error = function(err) {
    log.error("Error Accessing Directory", "IMPORT")
    return(list())
  })

  if(length(raw) == 0) {
    log.warn(paste("No Raw Files Found at ", dir.raw, sep = " "), "IMPORT")
  }

  # Remove File Extensions
  if(input.file.extension != "") {
    pattern <- paste("(", input.file.extension, ")", sep = "")
    raw.simple <- (raw[which(grepl(pattern = pattern, basename(raw)))])
  }
  raw.simple <- sub(pattern = "(.*)\\..", replacement = "\\1", basename(raw.simple))
  processed <- sub(pattern = "(.*)\\..", replacement = "\\1", basename(processed))

  # Expects raw and processed names to be the same
  raw <- raw[which(!raw.simple %in% processed)]
  return(raw)
}


##' @title Import EDF File
##'
##' @description A convience wrapper around FDBeye file importer to
##'      import using UTF-8 format
##'
##' @details Call edf2asc" R function to conver *edf files to *edf
##'     files.  This wrapper  only allows a single path instead of multiple.
##'     Existing *asc files will be overwritten because we se the option to -y.
##'
##' @param edf.file Path to *edf file in UTF-8 format (UNIX/MAC pathing).  Paths will
##'     be converted relative to your OS.
##'
##' @importFrom eyelinker read.asc
##' @return list of subject eye data, where each element is a list generated by eyelinker::read.asc
##' @examples
##' \dontrun{
##'   eye_parsed <- read_edf(c("~/Box/s3_behav_data/neighborhood/eye/data/raw/N_003_TS.edf",
##'       "~/Box/s3_behav_data/neighborhood/eye/data/raw/N_004_az.edf"), keep_asc=FALSE, parse_all=TRUE)
##' }
##' @export
read_edf <- function(edf_files, asc_output_dir=NULL, keep_asc=TRUE, gzip_asc=TRUE, samples=TRUE, ...) {#c. = 1, ...) {

  stopifnot(all(file.exists(edf_files))) #require that files are present
  if (!keep_asc) {
    asc_output_dir <- tempdir() #output ascs to temporary directory
  } else {
    if (!is.null(asc_output_dir) && !dir.exists(asc_output_dir)) { dir.create(asc_output_dir) } #create output directory for ASC files if requested
  }

  #convert all files to asc
  asc_files <- edf2asc(edf_files, asc_output_dir=asc_output_dir, gzip_asc=gzip_asc)

  #pass additional arguments such as parse_all to read.asc
  res <- lapply(asc_files, function(fname) {

    eye_data <- pkgcond::suppress_warnings(read.asc(fname=fname, samples=samples,...), pattern = "had status 255", fixed =TRUE)
    eye_data$asc_file <- fname
    class(eye_data) <-
      return(eye_data)
  })

  if (!keep_asc) { file.remove(asc_files) } #cleanup asc files if requested

  names(res) <- basename(edf_files)

  # tag with initial .edf name
  for(i in 1:length(res)){res[[i]][["edf_file"]] <- edf_files[i]}

  # to avoid confusion, re-label .edf "block" column with the more useful title "event" to fit with ep conventions.
  res <- lapply(res, function(x){ # over subjects
    lapply(x, function(y){ # over elements in ep.subject
      if("block" %in% names(y)){
        y <- y %>% rename(`eventn` = `block`)
      }
      return(y)
    })
  })


  cat("\n--------------\n1. Read EDF file: COMPLETE\n--------------\n")
  return(res)
}



#' Imports MAT files
#'
#' Imports MAT (matlab) data and creates asc as well as read the data
#' into dataframes.
#'
#' @param dir base directory for raw and proc directories.
#' @return list of edf file locations and edf data.
import.mat <- function(dir) {
  os <- NeuroMap$SYSTEM$os

  if(os == "Windows") {
    file.separator <- "\\"
  } else if(os == "OSX") {
    file.separator <- "/"
  }

  files.mat <- find.unprocessed(paste(dir, "raw", file.separator, sep = ''),
                                paste(dir, "proc", file.separator, sep = ''),
                                ".mat")
  subjects = list()

  mat.paths <- c()
  mat.data <- c()
  for(imp in files.mat) {
    # TODO Need more concrete file name and probably want to figure that out somewhere else
    log.info(paste("Importing mat file", imp, sep = " "), logger = "IMPORT")

    mat.datum <- R.matlab::readMat(paste(dir, "raw", file.separator, imp, sep = ''))
    mat.data <- c(mat.data, mat.datum)
  }

  return(list(mat.data = mat.data))
}


#' Imports Defend the Kingdom data
#'
#' Imports defend the kingdom data as dataframes.
import.dtk <- function() {
  print("Importing Defend The Kingdom")
}


#' Imports Neighborhood data
#'
#' Imports neighborhood data as dataframes.
import.neighborhood <- function() {
  print("Importing Neighborhood")
}


#' Imports shrooms data
#'
#' Imports shrooms data as dataframes.
#'
#' @param dir directory to import from
#' @return list of asc and mat data
import.shrooms <- function(dir) {
  log.info("Importing Shrooms Data", logger = "IMPORT")

  asc.data <- import.edf(dir)
  mat.data <- import.mat(dir)

  return(c(asc.data, mat.data))
}

#' Pipeline Block Function
#'
#' @param input empty import used for block
#'
#' @export
import.all <- function(input = list()) {
  create.log("IMPORT", level = NeuroMap$CONFIG$log_level_import)
  import.shrooms(NeuroMap$CONFIG$dir_shrooms)

  return(input)
}
